<!--
 * @Author: duanhaobin
 * @Date: 2021-03-16 09:11:46
 * @LastEditTime: 2021-03-20 12:39:43
 * @FilePath: \go-advanced-boot-camp\0x-Internet Program\02_GMP调度.md
-->
调度设计 ： https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/

**核心：**
Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。

## GMP调度核心概念
**核心：**
- G — 表示 Goroutine，每个go关键字都会创建一个goroutine；
  - 存放并发执行体的元信息，包括并发执行的入口函数、堆栈、上下文信息。
  - 数量限制，不超过256个
  - 优先将新建的g放入本地队列中，如果本地队列满了则放入全局队列中
- M — 表示操作系统的线程，当前操作系统分配到Go程序的内核线程数，它由操作系统的调度器调度和管理；统一管理P
  - Go本身限定M最大的数量为10000
  - 实际数量本身是动态的，如果有一个M处于阻塞状态，那么就会创建一个新的M
  - 如果有M空闲，那么就会回收或睡眠
  - M仅负责执行，M启动时进入运行时的管理代码，这段管理代码必须拿到可用的P后，才能执行调度
- P — Processor，是G和M之间抽象的一个中间层，在1.2之前是没有，之后才有，它表示M运行G所需要的资源，并不是处理器，尽管的它英文叫Processor。它是对资源的一种抽象和管理，并不是一段代码实体，而是一个管理的数据结构，P主要降低M管理调度G的复杂性，增加一个间接的控制层数据结构，P控制Go代码的并行度，不是运行实体。
  - P持有G的队列，可以隔离调度，解除P和M的绑定就是解除了M对一串G的调用
  - P在运行模型中只是一个数据模型，而不是程序控制模型，理解这一点非常重要。
  - 程序启动时创建
  - 最多有 GPMAXPROCS 个，默认和CPU的核数相同
  - 可以使用 `export GPMAXPROCS=8` 或 `runtime.GPMAXPROCS(8)` 来设置
- g0和m0，特殊的M和G
  - m0时启动程序后的主线程
  - 负责执行初识化操作，启动一第一个g，之后m0就和其他的M一样了

一个P同一时刻只能拿到一个G，然后交给对应的M去执行。

多个处理器就能在同一时刻执行多个M，进而通过P调度多个G来执行
### G
G并不是执行体，而是用于存放并发执行体的元信息，包括并发执行的入口函数、堆栈、上下文信息。

G由于保存的是元信息，为了减少对象的分配和回收，G对象是可以复用的，只需将元信息初识化为新值即可。
Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。

Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。

Goroutine 在 Go 语言运行时使用私有结构体 runtime.g 表示。这个私有结构体非常复杂，总共包含 40 多个用于表示各种状态的成员变量，这里也不会介绍所有的字段，仅会挑选其中的一部分，首先是与栈相关的两个字段：
```go
type g struct {
	stack       stack
	stackguard0 uintptr
}
```
**自旋线程状态**
如果其他本地队列有G，是不会让自旋线程状态保留的。自旋线程存在表示有的P没有挂载G，那么P自然就会偷取别人队列的G或者从全局去取

## GMP调度策略
### 复用线程
避免频繁的创建、销毁线程，而是对线程的复用，主要有两个机制
#### Work stealing机制
当本线程M的P队列中无可运行的g时：
1. 首先会从全局队列中获取G，此过程会有个加锁/释放锁的操作
2. 如果全局队列中也没有协程需要调度，则会从其他线程M绑定的P队列偷取G，每次偷取一半，而不是销毁线程，偷不到的话再考虑将线程销毁或睡眠

#### Hand off机制
当本线程M因为系统调用（如进行磁盘IO操作，read/write）而阻塞时，线程会释放绑定的P，把P转移给其他空闲线程M执行

### 利用并行
设置 `GPMAXPROCS`的值来控制P的数量 ，最多有 `GPMAXPROCS`个线程分布在多个CPU上同时进行
### 抢占式调度
所谓抢占式调度，是指避免某个协程长时间执行，而阻碍其他协程被调度的机制。

在 coroutine中要等待一个协程主动让出CPU才执行下一个协程。而在Go中，调度器会监控每个协程的执行时间，一个goroutine最多占用10ms，一旦执行时间超过，且有其他协程在等待时，会把协程暂停，转而调度其他等待的协程，以达到类似时间片轮转的效果，防止其他goroutine被饿死

从Go1.14开始，调度器引入了基于信号的抢占机制，这样就不会存在之前无限期占用线程执行权的问题。

## 调度循环
runtime.schedule 函数会从下面几个地方查找待执行的 Goroutine：

- 为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；
- 从处理器本地的运行队列中查找待执行的 Goroutine；
- 如果前两种方法都没有找到 Goroutine，会通过 runtime.findrunnable 进行阻塞地查找 Goroutine；

 runtime.findrunnable 的实现非常复杂，这个 300 多行的函数通过以下的过程获取可运行的 Goroutine：

- 从本地运行队列、全局运行队列中查找；
- 从网络轮询器中查找是否有 Goroutine 等待运行；
- 通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine，该函数还可能窃取处理器的计时器；

因为函数的实现过于复杂，上述的执行过程是经过简化的，总而言之，当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待。


## `go func(){}` 指令执行了哪些过程
![](https://img.kancloud.cn/76/4f/764f7be119026cc16314e87628e4013f_1920x1080.jpeg)

1. 我们使用 `go func(){}` 创建了一个goroutine
2. 有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列满了就会保存在全局队列中
3. G只能运行在M中，一个M必须持有一个P，M与P是 1:1 的关系。M会从P的本地队列中弹出一个可执行状态的G来执行，如果P的本地队列为空，优先向全局队列获取空闲的G，如果全局队列没有空闲的G，则会向其他的MP组合偷取可以执行的G来执行，每次偷取一半
4. 一个M调度G执行的过程是一个循环机制
5. 当M执行某一个G的时候发生了syscall 或其他阻塞操作，M就会阻塞；如果当前有一些G在执行，那么runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的M(操作系统的线程)来服务这个P，当然如果有空闲的线程M，就直接使用了，不会再创建新的M了
6. 当M系统调用结束，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列中。如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G也会放入到全局队列中去。

## 调度器的生命周期
![](https://img.kancloud.cn/b3/10/b31027eeb493fa86654b41d46f34a98b_439x872.png)